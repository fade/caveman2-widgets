* caveman2-widgets
** What is it
caveman2-widgets is an extension library to [[https://github.com/fukamachi/caveman][caveman2]]. It is influenced
by [[https://github.com/skypher/weblocks][Weblocks]] and introduces its widget system for the developer. By
only using its widget concept it does not control the developer as
much as Weblocks itself. For people who don't now Weblocks' aproach:
the developer can create web applications (more) like a normal GUI
application by using subclassable widgets which can have callbacks and
their like. Each Widget is only responsible for its own content but
might interfere with other objects. But the really cool part is that
the framework automatically creates your site for dynamically
(JavaScript based) access *and* normal access. For the dynamic
approach this means that you don't have to manage or even care to
refresh parts of your website, because widgets can do that
by themselves!
** Installation
You can use caveman2-widgets with Quicklisp!
#+BEGIN_SRC lisp
(ql:quickload :caveman2-widgets)
#+END_SRC

If you want to contribute or be always up to date you can clone this
git-repository into "~/quicklisp/local-projects" or (if you are using
[[https://github.com/roswell/roswell][Roswell]]) "~/.roswell/local-projects" to QUICKLOAD it.
** Contributions
You are very welcomed to contribute to this project! You can contribute by:
- Using it and spreading the word!
- Finding flaws and submitting [[https://github.com/ritschmaster/caveman2-widgets/issues][Issues]].
- Finding flaws and removing them (as [[https://github.com/ritschmaster/caveman2-widgets/pulls][Pull-requests]]).
- Adding new features (as [[https://github.com/ritschmaster/caveman2-widgets/pulls][Pull-requests]]). Before shooting in the dark
  create either an [[https://github.com/ritschmaster/caveman2-widgets/issues][Issues]] or mail me. Maybe your feature is on my
  agenda too.
- Showing your appreciation through a donation (please mail me for my
  data).

If you add new features, please document them. Otherwise other
developers will have a hard time using this framework.
** Usage
*** General 
The only important thing is to run the function INIT-WIDGETS with an
<APP>. If you use caveman's MAKE-PROJECT function you will get file
called "src/web.lisp". In this file you can adapt the following:
#+BEGIN_SRC lisp

(defpackage my-caveman2-webapp.web
  (:use :cl
        :caveman2
        :caveman2-widgets ;; easy use of the external symbols of this project
        :my-caveman2-webapp.config
        :my-caveman2-webapp.view
        :my-caveman2-webapp.db
        :datafly
        :sxql)
  (:export :*web*))

;; some other code

;; the following will be generated through MAKE-PROJECT but is very important:
(defclass <web> (<app>) ())
(defvar *web* (make-instance '<web>))
(clear-routing-rules *web*)


;; the neccessary call to initialize the widgets:
(init-widgets *web*)

;; from now on you can do whatever you want
#+END_SRC

*If you create objects from your widget classes, then please always
use the MAKE-WIDGET function!* This method should be used, since it
does all the background stuff for you.

*** Global scope
There are two scopes: /global/ and /session/. The global scope
"limits" the widget to *all* users. Therefore if you create a stateful
widget the state will be displayed to all users of your site. Use
MAKE-WIDGET with :GLOBAL to get a globally scoped widget.

A very simple example of what you can do with it:
#+BEGIN_SRC lisp
(defclass <global-widget> (<widget>)
  ((enabled
    :initform nil
    :accessor enabled)))

(defmethod render-widget ((this <global-widget>))
  (if (enabled this)
      "<h1>enabled!</h1>"
      "<h1>not enabled</h1>"))

(defvar *global-widget* (make-widget :global '<global-widget>))

(defroute "/" ()
  (render-widget *global-widget*))

(defroute "/disable" ()
  (setf (enabled *global-widget*) nil)
  "disabled it")

(defroute "/enable" ()
  (setf (enabled *global-widget*) t)
  "enabled it")
#+END_SRC

A good practice to create disposable widgets is to mark
them :GLOBAL. In the following example the widget will be created when
a user connects and will afterwards immediately be destroyed again by
the garbage collector.
#+BEGIN_SRC lisp
(defroute "/" ()
  (render-widget
    (make-widget :global '<string-widget>
                 :text "Hello world!"))
#+END_SRC

*** Session scope
The other option is to use a /session/ scope. This is a bit more
tricky because all your /session/ widgets must be stored within the
session (but not as user of this framework). :SESSION is the keyword
for MAKE-WIDGET to get a /session/ widget. Of course you only need to
save the top level (highest) widget of a widget tree in the session
(the children will be saved where the parent is). A short overview of
the functions:
- SET-WIDGET-FOR-SESSION :: Saves a widget in the session
     variable. This should be considered ONLY for session scoped
     widgets.
- GET-WIDGET-FOR-SESSION :: Gets a previously saved widget from the
     session variable (e.g. to render it).
- REMOVE-WIDGET-FOR-SESSION :: Removes a saved widget from the session
     variable.

An example (with children):
#+BEGIN_SRC lisp
(defclass <display-id-widget> (<widget>)
  ())

(defmethod render-widget ((this <display-id-widget>))
  (concatenate 'string
               "<h3>display-id-widget id: <a href=\"/rest/display-id-widget?id="
               (caveman2-widgets.widget::id this)
               "\">"
               (caveman2-widgets.widget::id this)
               "</a></h3>"))

(defclass <session-widget> (<widget>)
  ((id-widget
    :initform (make-widget :session '<display-id-widget>)
    :reader id-widget)))

(defmethod render-widget ((this <session-widget>))
  (concatenate 'string
               "<h1>The id of your widget</h1>"
               "<h2>It should be different for each session</h2>"
               "<p>My id: <a href=\"/rest/session-widget?id="
               (caveman2-widgets.widget::id this)
               "\">"
               (caveman2-widgets.widget::id this)
               "</a></p>"
               (render-widget (id-widget this)))) 

(defroute "/" ()
  (set-widget-for-session :session-widget
                          (make-widget :session '<session-widget>))
  (concatenate 'string
               "<head>
<script src=\"https://code.jquery.com/jquery-2.2.2.min.js\" type=\"text/javascript\"></script>
<script src=\"/widgets/js/widgets.js\" type=\"text/javascript\"></script>
</head>"

             (render-widget
              (get-widget-for-session :session-widget))
             (render-widget
              (make-widget :global '<button-widget>
                           :label "Reset session"
                           :callback #'(lambda ()
                                         (remove-widget-for-session 
                                          :session-widget))))))

(defroute "/reset-session" ()
  (remove-widget-for-session :session-widget)
  "reset your session")
#+END_SRC

*** Some default widgets
There are some helpful default widgets which may help you with your
code organisation. These are:
- <COMPOSITE-WIDGET> :: Contains multiple widgets which will be
     rendered vertically.
- <HCOMPOSITE-WIDGET> :: Like the <COMPOSITE-WIDGET> but renders the
     widgets horizontally.
- <STRING-WIDGET> :: A widget which renders only a string.
- <FUNCTION-WIDGET> :: A widget which uses a supplied function for
     rendering. Therefore the supplied function has to return a
     string!

A simple example:
#+BEGIN_SRC lisp
(defroute "/composite" ()
  (with-html-document (doc
                       (make-instance '<header-widget>))
    (setf (body doc)
          (make-widget :global '<hcomposite-widget>
                       :widgets (list
                                 (make-widget :global '<string-widget>
                                              :text "<h1>Hello from left</h1>")
                                 (make-widget :global '<function-widget>
                                              :function
                                              #'(lambda ()
                                                  "<h1>Hello from the mid</h1>"))
                                 (make-widget :global '<string-widget>
                                              :text "<h1>Hello from right</h1>"))))))
#+END_SRC
*** Buttons and links
    <<sec:ButtonsAndLinks>>
You can use buttons and links that call specific functions. When you
create a button/link only for a session the created route will be
guarded. Therefore only the user with the associated route may
actually access his button.

For each button there will be an URI like "/buttons/BUTTONID". You can
access buttons via POST only. Links get a URI like "/links/LINKID" and
can be accessed either by GET (get a redirect to the stored link) or
by POST (return only the value of the link). In any case the callback
function gets called - please keep that in mind.

An example:
#+BEGIN_SRC lisp
(defroute "/" ()
  (concatenate 'string
               (render-widget
                (make-widget :global '<link-widget>
                           :label "Github"
                           :callback #'(lambda ()
                               (format t "LOG: Link clicked!")
                               "http://github.com/ritschmaster")
                            :target-foreign-p t ;; The link goes out of this domain
                            ))
               (render-widget
                (make-widget :global '<button-widget>
                             :label "Button"
                             :callback #'(lambda ()
                                           (format t
                                                   "LOG: Button clicked!"))))))
#+END_SRC

You can create your own callback widgets too. Just look at the
<CALLBACK-WIDGET>, <BUTTON-WIDGET> classes for that.

*** Use caveman2-widgets for your entire HTML document
To make your life really easy you can create an entire HTML
document. You can either tinker your own widgets or whatever with the
<HMTL-DOCUMENT-WIDGET> and the <HEADER-WIDGET> or you can use the
handy WITH-HTML-DOCUMENT macro.

#+BEGIN_SRC lisp
(defclass <root-widget> (<body-widget>)
  ())

(defmethod render-widget ((this <root-widget>))
  "Hello world!")

(defclass <otherpage-widget> (<body-widget>)
  ())

(defmethod render-widget ((this <otherpage-widget>))
  "Hello from the other page!")

(defvar *header-widget* (make-instance '<header-widget>
                                       ;; the title when this header is used
                                       :title "Widgets test"

                                       ;; the icon when this header is used
                                       :icon-path "/images/icon.png"

                                       ;; the following lines will be rendered in the header:
                                       :other-header-content 
                                       '("<meta name=\"author\" content=\"Richard Bäck\">"))
(defvar *root-widget* (make-widget :global '<root-widget>))
(defvar *otherpage-widget* (make-widget :global '<otherpage-widget>))

(defroute "/" ()
  ;; The *root-widget* can be accessed under:
  ;; /rest/root-widget?id=(caveman2-widgets.widget::id *root-widget*)
  (render-widget
   (make-instance '<html-document-widget>
                  ;; sets this specific header for this page
                  :header *header-widget*
                  :body *root-widget*)))
(defroute "/otherpage" ()
  (with-html-document (doc
                       *header-widget*)
    (setf (body doc)
           *otherpage-widget*)))

#+END_SRC

*** Marking widgets dirty
You can mark specific widgets as dirty with the function
MARK-DIRTY. This means that they will be reloaded dynamically (if the
user has JavaScript is enabled). Please notice that you can mark *any*
widget as dirty. Therefore you can order JavaScript to reload global
widgets and sessioned widgets.

An example:
#+BEGIN_SRC lisp
(defclass <sessioned-widget> (<widget>)
  ((enabled
    :initform nil
    :accessor enabled)))

(defmethod render-widget ((this <sessioned-widget>))
  (concatenate 'string
               "<h2>Sessioned-widget:</h2>"
               (if (enabled this)
                   "<h3>enabled!</h3>"
                   "<h3>not enabled</h3>")))


(defclass <my-body-widget> (<widget>)
  ())

(defmethod render-widget ((this <my-body-widget>))
  (concatenate 'string
               "<h1>MARK-DIRTY test</h1>"
               (render-widget
                (get-widget-for-session :sessioned-widget))
               (render-widget
                (make-widget
                 :global '<button-widget>
                 :label "Enable"
                 :callback #'(lambda ()
                     (let ((sessioned-widget
                            (get-widget-for-session :sessioned-widget)))
                       (when sessioned-widget
                         (setf (enabled sessioned-widget) t)
                         (mark-dirty sessioned-widget))))))
               (render-widget
                (make-widget
                 :global '<button-widget>
                 :label "Disable"
                 :callback #'(lambda ()
                     (let ((sessioned-widget
                            (get-widget-for-session :sessioned-widget)))
                       (when sessioned-widget
                         (setf (enabled sessioned-widget) nil)
                         (mark-dirty sessioned-widget))))))))

(defvar *header-widget* (make-instance '<header-widget>
                                       :title "Mark-dirty test"))
(defvar *my-body-widget* (make-widget :global '<my-body-widget>))

(defroute "/mark-dirty-test" ()
  (set-widget-for-session :sessioned-widget (make-widget :session '<sessioned-widget>))
  (render-widget
   (make-instance '<html-document-widget>
                  :header *header-widget*
                  :body *my-body-widget*)))
#+END_SRC

*** Navigation objects
You can create navigation objects too! The purpose of navigation
objects is that you don't have to manage a navigation ever again!
Each navigation object contains another widget which displays the
currently selected path. If you click on a navigation link that object
is changed and refreshed (either via JavaScript or through the
link). Please keep in mind that navigation objects are *session
stateful widgets*.

A very basic example:
#+BEGIN_SRC lisp
(defvar *first-widget*
  (make-widget :global '<string-widget>
               :text "<h1>Hello world from first</h1>"))

(defvar *second-widget*
  (make-widget :global '<string-widget>
               :text "<h1>Hello world from second</h1>"))

(defclass <proxy-widget> (<widget>)
  ()
  (:documentation "This class enables session based widgets for a
navigation."))

(defmethod render-widget ((this <proxy-widget>))
  (set-widget-for-session :string-widget
                          (make-widget :session '<string-widget>
                                       :text "hello world"))
  (render-widget (get-widget-for-session :string-widget)))

(defnav "/sophisticated/path"
    ((make-instance '<bootstrap-header-widget>
                    :title "Navigation test")
     (list
      (list "First widget" "first" *first-widget*)
      (list "Second widget" "second" *second-widget*)
      (list "Third widget" "third" (make-widget :global
                                                '<proxy-widget>))))) 
#+END_SRC

If the default navigation object doesn't render as you wish, you can
subclass it and overwrite the RENDER-WIDGET method. Please notice that
you can actually very easily adjust the path where the navigation and
its widgets get rendered. The slot BASE-PATH is created for that.

There are two default navigation widgets:
- <MENU-NAVIGATION-WIDGET> :: A navigation with a menu. You can change
     the menu appearance with CSS.
- <BLANK-NAVIGATION-WIDGET> :: A navigation without any menu. It is
     controlled by the URL only - or by other widgets.
*** Table objects
You can create a table very simple. Just use the <TABLE-WIDGET> or if
you want something more sophisticated the <LIMITED-TABLE-WIDGET>. The
difference between the two is that <TABLE-WIDGET> just displays *all*
items which are supplied through the PRODUCER function while the
<LIMITED-TABLE-WIDGET> shows only a window of the available items.

Important for the usage of tables is that you supply a PRODUCER
function. The function should return a list of <TABLE-ITEM>
objects. This function can be anything but it has to take the key
arguments:
- AMOUNT :: Tells how many items to get
- ALREADY :: Tells how many items already received
- LENGTH-P :: A flag which should tell the function to return the
              available items if active.
AMOUNT and ALREADY can be seen as synonyms for FROM and TO.

A <TABLE-ITEM> object is needed for tables. The essence of those
objects is that they can be translated to lists through the generic
function GET-AS-LIST. Therefore you don't have to subclass
<TABLE-ITEM> at all just to add an implementation of GET-AS-LIST for
your used class.

For the <TABLE-Widget> consider the following example:
#+BEGIN_SRC lisp
(defclass <my-item> (<table-item>)
  ((id
    :initarg :id
    :reader id)
   (name
    :initarg :name
    :reader name)
   (description
    :initarg :description
    :reader description)))

(defmethod get-as-list ((this <my-item>))
  (list :id (id this)
        :name (name this)
        :description (description this)))

(defun producer (&key
                   amount
                   (already 0)
                   (length-p nil))
  (if (null length-p)
      (let ((all '()))
        (if (null amount)
            (loop for x from 1 to 1000 do
                 (setf all
                       (append all
                               (list
                                (make-instance '<my-item>
                                               :id x
                                               :name (format nil "~a" x)
                                               :description (format nil "The ~a. item." x))))))
            (loop for x from (+ already 1) to (+ already amount) do
                 (setf all
                       (append all
                               (list
                                (make-instance '<my-item>
                                               :id x
                                               :name (format nil "~a" x)
                                               :description (format nil "The ~a. item." x)))))))
        all)
      1000))

(defvar *table-widget*
  (make-widget :global '<table-widget>
               :producer 'producer
               :column-descriptions (list
                                     (list :name "Name")
                                     (list :description "Description"))))

(defroute "/table" ()
  (with-html-document (doc
                       (make-instance '<header-widget>))
    (setf (body doc)
          *table-widget*)))
#+END_SRC

The <LIMITED-TABLE-WIDGET> can be used as follows:
#+BEGIN_SRC lisp
TODO! The <limited-table-widget> is not yet done! 
#+END_SRC
*** Translations
Most strings that are rendered for a human readable get translated
through a special function. You can specify you own translation
function by passing it to INIT-WIDGETS as :TRANSLATION-FUNCTION. The
function header should look like this:
#+BEGIN_SRC lisp
(defvar *my-translation-function*
         #'(lambda (text
                     &key
                       plural-p
                       genitive-form-p
                       items-count
                       accusative-form-p
                       language
                     &allow-other-keys)
             text))
#+END_SRC

Strings that are translated:
- The page names of a navigation

Strings that are definitely *not* translated:
- The TEXT of a <STRING-WIDGET>
- The return value of a <FUNCTION-WIDGET>
** Things that happen automatically
The following things you should keep in mind when using
caveman2-widgets.

*** Automatically REST API creation
If you create a widget then routes for a REST API will be added
automatically. Suppose you subclass <widget> with the class
"<my-widget>", then you will get the path "/rest/my-widget" which you
can access.

#+BEGIN_SRC lisp
(defclass <my-widget> (<widget>)
  ())

(defmethod render-widget ((this <my-widget>))
  "my-widget representation for the website")

(defmethod render-widget-rest ((this <my-widget>) (method (eql :get)) (args t))
  "my-widget representation for the REST.")

(defmethod render-widget-rest ((this <my-widget>) (method (eql :post)) (args t))
  (render-widget this))
#+END_SRC

Buttons and Links are not accessed through the /rest/ path (see
[[sec:ButtonsAndLinks]]).

Widgets that are not accessible through the REST:
- <HTML-DOCUMENT-WIDGET>
- <HEADER-WIDGET>

*** Encapsulating widgets with divs
Each widget gets wrapped in a div automatically. Therefore you can
access every widget (and derived widget) very easily with CSS.

*** JavaScript dependencies
When <HEADER-WIDGET> is used all JavaScript dependencies are added
automatically. Please notice that these dependecies are needed to
ensure that the widgets work properly. If you don't want to use
<HEADER-WIDGET> you have to manually add jQuery and all the JavaScript
Code supplied/needed by caveman2-widgets.

The routes for the JavaScript files (which have to be included in each
HTML file) are:
- /widgets/js/widgets.js

The jQuery-Version used is 2.2.2 minified. If you want another jQuery
file you can specify it with the variable *jquery-cdn-link* (should be
an URL).

*If you forget to use the JavaScript-files widgets might not work or
even break. Most likely all dynamic content just won't work
(automatically fallback to non-JS)*

*** Session values
This section should inform you about keywords in the session variable
which you should absolutely not modify.
- :WIDGET-HOLDER
- :DIRTY-OBJECT-IDS
- :JAVASCRIPT-AVAILABLE

** Author

+ Richard Paul Bäck (richard.baeck@free-your-pc.com)

** Copyright

Copyright (c) 2016 Richard Paul Bäck (richard.baeck@free-your-pc.com)

** License

Licensed under the LLGPL License.
